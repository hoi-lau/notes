# JSON Web Token

JSON Web令牌（JWT）是一个开放标准（[RFC 7519](https://tools.ietf.org/html/rfc7519)），它定义了一种紧凑且自包含的方式，用于在各方之间安全地将信息作为JSON对象传输。由于此信息是经过数字签名的，因此可以被验证和信任。可以使用秘密（使用**HMAC**算法）或使用**RSA**或**ECDSA**的公用/专用密钥对对JWT进行**签名**。

尽管可以对JWT进行加密以在各方之间提供保密性，但我们将重点关注已*签名的*令牌。签名的令牌可以验证其中包含的声明的*完整性*，而加密的令牌则将这些声明*隐藏*在其他方的面前。当使用公钥/私钥对对令牌进行签名时，签名还证明只有持有私钥的一方才是对其进行签名的一方。

JSON Web Token（JWT）是目前最流行的跨域身份验证解决方案(**我感觉比较鸡肋**)

<b>不要将jwt变成有状态的</b>

## 结构

-  Header 标头
  -  令牌的类型（即JWT）和所使用的签名算法组成
-  Payload 有效载荷
-  Signature 签名

## jwt最佳使用场景

 JWT 最适合的场景是不需要服务端保存用户状态的场景，如果考虑到 token 注销和 token 续签的场景话，没有特别好的解决方案，大部分解决方案都给 token 加上了状态，这就有点类似 Session 认证了。 

- 有效期短

- 只希望被使用一次

真实场景的例子——文件托管服务，由两部分组成：

  - Web 应用：这是一个可以被用户登录并维持状态的应用，用户在应用中挑选想要下载的文件。
  - 文件下载服务：无状态下载服务，只允许通过密钥下载。

## cookie

Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。Cookie存储的数据量有限，且都是保存在客户端浏览器中。不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie实际上只能存储一小段的文本信息。

cookie参与服务器端通信，每次都会携带http的头信息中

## session

Session是另一种记录客户状态的机制，它是在服务端保存的一个数据结构（主要存储的的SessionID和Session内容，同时也包含了很多自定义的内容如：用户基础信息、权限信息、用户机构信息、固定变量等），这个数据可以保存在集群、数据库、文件中，用于跟踪用户的状态。

客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。

用户第一次登录后，浏览器会将用户信息发送给服务器，服务器会为该用户创建一个SessionId，并在响应内容（Cookie）中将该SessionId一并返回给浏览器，浏览器将这些数据保存在本地。当用户再次发送请求时，浏览器会自动的把上次请求存储的Cookie数据自动的携带给服务器。

服务器接收到请求信息后，会通过浏览器请求的数据中的SessionId判断当前是哪个用户，然后根据SessionId在Session库中获取用户的Session数据返回给浏览器。

`Session`比较适用于Web应用的会话管理，其特点一般是：

- 权限多，如果用`JWT`则其长度会很长，很有可能突破Cookie的存储限制。
- 基本信息容易变动。如果是一般的后台管理系统，肯定会涉及到人员的变化，那么其权限也会相应变化，如果使用`JWT`，那就需要服务器端进行主动失效，这样就将原本无状态的`JWT`变成有状态，改变了其本意。

## token

HTTP请求都是以无状态的形式对接。即HTTP服务器不知道本次请求和上一次请求是否有关联。所以就有了Session的引入，即服务端和客户端都保存一段文本，客户端每次发起请求都带着，这样服务器就知道客户端是否发起过请求。

这样，就导致客户端频繁向服务端发出请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否。而Session的存储是需要空间的，频繁的查询数据库给服务器造成很大的压力。

## JWT 的缺点

**（1）体积大**

如果把 session 信息编码后放入 token，那么其体积会很大，很有可能超出 cookie 的大小限制，那就只能把 JWT 保存在 Local Storage 了，也就产生了安全问题。

而且，体积大，网络压力就大了。

**（2）不安全**

如果放在 cookie 里，那和传统的 session 方案就差不多了，如果放在别的地方，就有其他安全问题了。

**（3）无法使某个 JWT 无效**

不像 session，在服务端可以使其失效，而 JWT 直到其过期才能无效。

比如服务端检测到了一个安全威胁，也无法使相关的 JWT 失效。

也就是说，当你发现风险时，无法杀死某个 session，如果你想解决这个问题，就需要服务端可以对 session 进行管理，那么就变回有状态的模式了。

**（4）session 数据旧了**

session 数据是保存在 JWT 中的，其中会有用户的相关信息，例如角色。

在 JWT 过期之前，用户的角色发生了变化，那么这时 JWT 中的信息就是旧的了，因为无法更新。