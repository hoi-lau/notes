# ioc

对象仅通过构造函数参数，工厂方法的参数,或在对象实例上设置的属性来定义其依赖项.容器创建bean时会注入依赖项.

 此过程从根本上讲是通过使用类的直接构造或诸如服务定位器模式之类的方法来控制其依赖项的实例化或位置的bean本身的逆过程（因此称为Control Inversion）。 

## Bean加载顺序

spring初始化bean顺序: 包从上到下,类从上到下...  **不应该依赖它**

由`ioc`管理的bean默认是单例的

使用`@DependsOn`注解可以控制bean初始化顺序

## DI

推荐使用构造器注入,可以确保依赖项不是null,如果构造函数有过多的参数,此时class应该重构.

1. 字段注入。 不推荐.

   - 优点: 简洁,容易扩展
   - 缺点: 容易空指针

2. 构造器注入。强依赖

   当你使用构造器方式注入，构造器参数的数量就会变得太多以至于很容易出现错误。拥有太多的依赖通常意味着你的类要承担更多的责任，明显违背了单一职责原则和关注点分离，这表明该类需要进一步检查和重构。

3. set注入。弱依赖

## 循环依赖

 Class A 需要通过构造函数注入实现 class B，而 class B 需要通过构造函数注入实现 class A.如果为 classes A 和 B 配置 beans 以相互注入，则 Spring IoC 容器会在运行时检测到此循环 reference，并抛出`BeanCurrentlyInCreationException` 

 一种可能的解决方案是编辑某些 classes 的 source code，以便由 setter 而不是构造函数配置。或者，避免构造函数注入并仅使用 setter 注入。换句话说，尽管不推荐使用，但您可以使用 setter 注入配置循环依赖项 

## spring是如何解决循环依赖?

**spring无法解决构造器注入引发的循环依赖**

spring现将Bean对象实例化(通过无参构造器)=>设置对象属性

### 如何检测是否有循环依赖?

在Bean创建时打个标记(创建中),如果递归调用回来发现还是处于创建中的状态=>循环依赖