---
title: 「v8」编译过程
date: 2022-04-13
categories:
 - chromium
tags:
 - v8
---

> 理解 JavaScript 引擎工作原理有助于写出高效的 JavaScript 代码,本文简单的了解一下v8编译过程


**一个编译程序的结构**

![](https://img.imliuk.com/20220512164409.JPG)

**V8 的编译过程**

![](https://img.imliuk.com//20220511170529.svg)

在v8中,编译的代码实现是v8::Script::Compile 方法.

用v8提供的samples断点调试,总结出编译过程中一些关键的方法:

![](https://img.imliuk.com/20220705113735.png)

从这里开始追踪代码可以看到生成ast的全部流程:

```cpp
// Parser::ParseProgram源码(编译开始):
void Parser::ParseProgram(Isolate* isolate, Handle<Script> script,
                          ParseInfo* info,
                          MaybeHandle<ScopeInfo> maybe_outer_scope_info) {
  DCHECK_EQ(script->id(), flags().script_id());

  // It's OK to use the Isolate & counters here, since this function is only
  // called in the main thread.
  DCHECK(parsing_on_main_thread_);
  RCS_SCOPE(runtime_call_stats_, flags().is_eval()
                                     ? RuntimeCallCounterId::kParseEval
                                     : RuntimeCallCounterId::kParseProgram);
  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("v8.compile"), "V8.ParseProgram");
  base::ElapsedTimer timer;
  if (V8_UNLIKELY(FLAG_log_function_events)) timer.Start();

  // Initialize parser state.
  DeserializeScopeChain(isolate, info, maybe_outer_scope_info,
                        Scope::DeserializationMode::kIncludingVariables);

  DCHECK_EQ(script->is_wrapped(), info->is_wrapped_as_function());
  if (script->is_wrapped()) {
    maybe_wrapped_arguments_ = handle(script->wrapped_arguments(), isolate);
  }

  scanner_.Initialize();
  FunctionLiteral* result = DoParseProgram(isolate, info);
  MaybeProcessSourceRanges(info, result, stack_limit_);
  PostProcessParseResult(isolate, info, result);

  HandleSourceURLComments(isolate, script);

  if (V8_UNLIKELY(FLAG_log_function_events) && result != nullptr) {
    double ms = timer.Elapsed().InMillisecondsF();
    const char* event_name = "parse-eval";
    int start = -1;
    int end = -1;
    if (!flags().is_eval()) {
      event_name = "parse-script";
      start = 0;
      end = String::cast(script->source()).length();
    }
    LOG(isolate,
        FunctionEvent(event_name, flags().script_id(), ms, start, end, "", 0));
  }
}
```

`scanner_.Initialize()`会初始化`scanner`,也就是词法分析器,同时读取一个token.

`DoParseProgram(isolate, info)`表示语法分析的开始,返回的结果就是Ast.

**后台编译**

从 Chrome 66 开始,V8 可以在后台线程上编译 JavaScript 源代码,后台编译可以让主线程空闲更长的时间.目前，只有顶层代码和立即调用的函数表达式（IIFE）在后台线程上编译,内部函数仍然在主线程上延迟编译。

**lazy parsing**

v8实现了lazy parsing(延迟编译),在遇到函数时进行预解析(pre-parse), 而不是完全解析, 这样可以减少编译时间提升应用启动速度,同时减少内存占用(代码对象也是要占用内存的).预解析不会生成Ast,函数在第一次被调用时,会进行完全解析和编译.预解析由PreParser类实现.

**顶层代码**

以下代码,除了function body部分,其他是顶层代码.

```JavaScript
const name = 'k'
function fullName(_name) {
  return _name + name
}
```

## AstNode

AstNode继承自ZoneObject. AstNode数据结构:

![](https://img.imliuk.com/20220705173119.png)

![](https://img.imliuk.com/20220705171918.png)

## 字节码生成

> 字节码是机器码的抽象形式.

生成Ast后,准备并执行最外层函数的编译, 入口: `job->ExecuteJob()`, BytecodeGenerator负责字节码的生成.

使用v8提供的工具d8可以生成js文件对应的字节码.

js文件 bcode.js:

```JavaScript
function acc(i, j) {
  console.log(i + j)
}

acc(1, 1)
```

```sh
# 生成字节码
d8  --print-bytecode  bcode.js > bytecode.log
# 生成ast
d8  --print-ast  bcode.js > ast.log
```

生成的Ast
```txt
[generating bytecode for function: ]
--- AST ---
FUNC at 0
. KIND 0
. LITERAL ID 0
. SUSPEND COUNT 0
. NAME ""
. INFERRED NAME ""
. DECLS
. . FUNCTION "acc" = function acc
. EXPRESSION STATEMENT at 45
. . ASSIGN at -1
. . . VAR PROXY local[0] (0x7fd23803f2e8) (mode = TEMPORARY, assigned = true) ".result"
. . . CALL
. . . . VAR PROXY unallocated (0x7fd23803f1e0) (mode = VAR, assigned = true) "acc"
. . . . LITERAL 1
. . . . LITERAL 1
. RETURN at -1
. . VAR PROXY local[0] (0x7fd23803f2e8) (mode = TEMPORARY, assigned = true) ".result"

[generating bytecode for function: acc]
--- AST ---
FUNC at 12
. KIND 0
. LITERAL ID 1
. SUSPEND COUNT 0
. NAME "acc"
. PARAMS
. . VAR (0x7fd23803f270) (mode = VAR, assigned = false) "i"
. . VAR (0x7fd23803f2f0) (mode = VAR, assigned = false) "j"
. DECLS
. . VARIABLE (0x7fd23803f270) (mode = VAR, assigned = false) "i"
. . VARIABLE (0x7fd23803f2f0) (mode = VAR, assigned = false) "j"
. EXPRESSION STATEMENT at 23
. . CALL
. . . PROPERTY at 31
. . . . VAR PROXY unallocated (0x7fd23803f4a8) (mode = DYNAMIC_GLOBAL, assigned = false) "console"
. . . . NAME log
. . . ADD at 37
. . . . VAR PROXY parameter[0] (0x7fd23803f270) (mode = VAR, assigned = false) "i"
. . . . VAR PROXY parameter[1] (0x7fd23803f2f0) (mode = VAR, assigned = false) "j"

2

```

生成的字节码:

```txt
[generated bytecode for function:  (0x21cb00253701 <SharedFunctionInfo>)]
Bytecode length: 28
Parameter count 1
Register count 4
Frame size 32
OSR urgency: 0
Bytecode age: 0
         0x21cb002537c4 @    0 : 13 00             LdaConstant [0]
         0x21cb002537c6 @    2 : c3                Star1 
         0x21cb002537c7 @    3 : 19 fe f8          Mov <closure>, r2
         0x21cb002537ca @    6 : 65 57 01 f9 02    CallRuntime [DeclareGlobals], r1-r2
         0x21cb002537cf @   11 : 21 01 00          LdaGlobal [1], [0]
         0x21cb002537d2 @   14 : c3                Star1 
         0x21cb002537d3 @   15 : 0d 01             LdaSmi [1]
         0x21cb002537d5 @   17 : c2                Star2 
         0x21cb002537d6 @   18 : 0d 01             LdaSmi [1]
         0x21cb002537d8 @   20 : c1                Star3 
         0x21cb002537d9 @   21 : 63 f9 f8 f7 02    CallUndefinedReceiver2 r1, r2, r3, [2]
         0x21cb002537de @   26 : c4                Star0 
         0x21cb002537df @   27 : a9                Return 
Constant pool (size = 2)
0x21cb00253791: [FixedArray] in OldSpace
 - map: 0x21cb00002239 <Map>
 - length: 2
           0: 0x21cb00253749 <FixedArray[2]>
           1: 0x21cb002536d1 <String[3]: #acc>
Handler Table (size = 0)
Source Position Table (size = 0)
[generated bytecode for function: acc (0x21cb00253759 <SharedFunctionInfo acc>)]
Bytecode length: 22
Parameter count 3
Register count 3
Frame size 24
OSR urgency: 0
Bytecode age: 0
         0x21cb002538f8 @    0 : 21 00 00          LdaGlobal [0], [0]
         0x21cb002538fb @    3 : c3                Star1 
         0x21cb002538fc @    4 : 2d f9 01 02       GetNamedProperty r1, [1], [2]
         0x21cb00253900 @    8 : c4                Star0 
         0x21cb00253901 @    9 : 0b 04             Ldar a1
         0x21cb00253903 @   11 : 39 03 04          Add a0, [4]
         0x21cb00253906 @   14 : c2                Star2 
         0x21cb00253907 @   15 : 5e fa f9 f8 05    CallProperty1 r0, r1, r2, [5]
         0x21cb0025390c @   20 : 0e                LdaUndefined 
         0x21cb0025390d @   21 : a9                Return 
Constant pool (size = 2)
0x21cb002538c5: [FixedArray] in OldSpace
 - map: 0x21cb00002239 <Map>
 - length: 2
           0: 0x21cb000045c1 <String[7]: #console>
           1: 0x21cb001c27a9 <String[3]: #log>
Handler Table (size = 0)
Source Position Table (size = 0)
2

```

完整指令集定义: src/interpreter/bytecodes.h 

部分指令含义: 

| 指令  | 含义 |
| ---- | ---- |
|  Ldar | 加载数据到累加器 |
| Ldar a1 | a1代表函数的args[1],加载到累加器 |
| LdaSmi [1] | 将整数1加载到累加器 |
|  Star1 | 累加器中的值写入到r1寄存器 |
| Add r0 | 将累加器中的值与寄存器r0中的值进行加法运算,存到累加器中 |
| Sub r2 | 累加器中的值减去寄存器r2中的值,存到累加器中 |
| CallProperty0 r0, r1 | 类似于 r0.r1(),存到累加器中 |
| CallProperty1 r0, r1, r2 | 类似于 r0.r1(r2),存到累加器中 |
| LdaConstant [0] | 加载常量池(Constant pool)中索引为0的值到累加器 |
| LdaNamedProperty r1, [1], [2] | 获取r1寄存器的属性值为常数池索引为1的值, 2代表函数的所谓反馈向量的索引。 反馈向量包含用于性能优化的运行时信息。 |
| Return | 返回累加器的值 |
| LdaUndefined | 同理, 加载undefined到累加器 |
| CreateObjectLiteral [0], [0], #8 | 创建对象,存到累加器中 |

通过这个表格,可以很清晰的看到源码和生成的字节码之间的对应关系,由此,可以通过反编译得到字节码对应的源码.